# 선택 알고리즘

배열에서 i번째 작은 원소를 찾는 문제?

-> n개의 원소 각각을 적어도 한번씩은 봐야하므로 Ω(n)
-> O(n log n) 알고리즘으로 정렬한 후 i번째 원소를 고르면 되므로 O(n log n)

## 두 가지 선택 알고리즘

1. 평균적으로 선형시간이 소요되는 선택 알고리즘 `select`
2. 최악의 경우에도 선형시간이 보장되는 선택 알고리즘 `linearSelect`

> 선형시간이란 n에 비례한 시간을 말한다.

## 선형시간 선택 알고리즘

```ts
function select(A: number[], p: number, r: number, i: number) {
  if (p === r) return A[p]; // 원소가 하나뿐인 경우. i는 반드시 1
  const q = partition(A, p, r); // 퀵 정렬의 partition과 동일
  const k = q - p + 1; // 기준원소가 A[p..r]에서 k번째 작은 원소임을 의미

  if (i < k) return select(A, p, q - 1, i); // 왼쪽 분할로 범위를 좁힙
  else if (i === k) return A[q]; // 기준원소가 찾는 원소
  else return select(A, q + 1, r, i - k); // 오른쪽 분할로 범위를 좁힘
}
```

![스크린샷 2022-04-26 오전 12 52 50](https://user-images.githubusercontent.com/26461307/165126454-e1ab28ac-e55b-4fa4-b9c4-a4a5fc587c43.png)

평균 수행시간 = `Θ(n)`
최악의 경우 수행시간 = `Θ(n^2)`

> 즉, 분활의 균형의 영향을 받는다.

## 분할과 선택 알고리즘 수행시간

- 분할의 균형이 일정 비율 이상으로 나빠지지 않도록 전처리

1. 원소가 5개 이하면 i번째 작은 원소를 찾고 알고리즘을 끝낸다.
2. 전체 원소 n개를 원소 수 5인 작은 그룹들로 나눈다
3. 각 그룹에서 중앙값을 찾는다. (m1, m2, m3, ...)
4. m1, m2, m3, ...의 중앙값 M을 재귀적으로 구한다.
   -  mk 값들이 홀수개면 중앙값이 하나이므로 문제없지만, 짝수개면 두 중앙값 중 임의로 하나를 선택
5. M을 기준원소로 삼아 전체 원소를 분할한다.
6. 분할된 두 쪽 중 i번째 작은 원소가 속해 있을 쪽은 선택하여 1~6단계를 재귀적으로 반복

평균 수행시간 = `Θ(n)`
최악의 경우 수행시간 = `Θ(n)`