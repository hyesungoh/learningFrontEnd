# 추리 게임

실습 프로젝트를 통해 러스트를 사용해보는 과정

여기서는 실제 프로젝트에서 몇몇 일반적인 Rust 개념이 어떻게 활용되는지 소개해, `let`, `match`, `메소드`, `연관함수(associated functions)`, `외부 크레이트(external crates)`의 활용 방법을 배울 수 있음

## 결과물

1~100 사이의 임의의 정수를 생성하고, 플레이어가 추리한 정수를 입력.
그리고 프로그램은 입력받은 추리값이 정답보다 높거나 낮은지를 알려주는 프로그램

## 표준 입출력

사용자 입력을 받고 결과값을 표시하기 위해서는 `io` 라이브러리를 스코프로 가져와야 하고, 이는 `std`라 불리는 표준 라이브러리가 있음

```rs
use std::io;
```

## 변수

```rs
let foo = 5; // 불변 변수
let mut guess = String::new(); // 가변 변수
```

러스트의 변수는 기본적으로 불변

### String::new()

- String은 표준 라이브러리에서 제공하는 확장 가능한 UTF-8 인코딩의 문자열 타입

`::new`에 있는 `::`는 new가 String 타입의 **연관함수**임을 나타냄

- 연관함수는 하나의 타입을 위한 함수
- 이 경우에는 하나의 String 인스턴스가 아니라 String 타입을 위한 함수
- 몇몇 언어에서는 이것을 **정적 메소드**라고 부름

## 입력

```rs
io::stdin().read_line(&mut guess)
    .expect("Failed to read line");
```

### `io::stdin()`

- `io`의 연관함수인 `stdin`을 호출
  - 만약 `use std::io`문을 작성하지 않았으면, `std::io::stdin`처럼 작성해야 함
- stdin 함수는 터미널의 표준 입력의 핸들(handle) 타입인 `std::io::Stdin`의 인스턴스를 반환

### `.read_line(&mut guess)`

- 입력을 받기 위해 표준 입력 핸들에서 `read_line` 메소드를 호출하는 것
- `read_line`의 인자로 `&mut guess`를 넘김
- `read_line`은 입력된 문자들을 하나의 문자열에 저장하므로, 인자로 값을 저장할 문자열이 필요하며 이는 **가변**이어야 함

- `&`는 여러 부분에서 데이터를 메모리로 복사하지 않고 접근하기 위한 **참조자**
  - 참조자를 사용함으로써 러스트는 안전성과 용이성을 얻음
  - 참조자는 변수처럼 기본적으로 **불변**
  - 가변으로 바꾸기 위해 `&guess`가 아닌 `&mut guess`로 작성한 것

## 실패 다루기

`read_line`은 인자로 넘긴 문자열에 입력값을 저장할 뿐 아니라 하나의 값을 반환하는데,

여기서 돌려준 값은 `io::Result`

> 러스트는 표준 라이브러리에 여러 종류의 Result 타입을 가지고 있는데, `제네릭 Result`이나, `io::Result`가 그 예시

`Result` 타입은 **열거형 (enums)**

> Enum은 정해진 값들만 가질 수 있으며 이러한 값들은 열거형의 variants라고 부름

Result의 variants는 `Ok`와 `Err`, `Ok`는 처리가 성공했음을 나타내며 `Err`은 처리가 실패했음을 나타내고 그 이유에 대한 정보를 가지고 있음

Result 타입은 다른 타입들처럼 메소드들을 가지고 있는데, `io::Result` 인스턴스는 `expect` 메소드를 가지고 있음

- `io::Result`의 인스턴스가 `Err`일 경우 expect 메소드는 프로그램 작동을 멈추고 expect 인자로 넘겼던 메세지를 출력함

```rs
io::stdin().read_line(&mut guess);
```

만약 위처럼 `expect`를 호출하지 않는다면 컴파일은 되지만 경고 메세지가 나오게 됨
