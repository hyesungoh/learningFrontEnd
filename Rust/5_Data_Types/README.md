# Data types

러스트의 타입은 크게 **스칼라**와 **컴파운드** 둘로 나눌 수 있음

> 러스트는 타입이 고정된 언어인데, 이것이 의미하는 바는 모든 변수의 타입이 컴파일 시에 반드시 정해져 있어야 한다는 것

## 스칼라 타입

스칼라는 하나의 값으로 표현되는 타입은

- 정수형
- 부동소수점 숫자
- boolean
- 문자

러스트는 위 네 가지 스칼라 타입을 보유하고 있음

### 정수형

소수점이 없는 숫자로써 부호의 여부, 길이로 나뉨

| length | signed | unsigned |
| ------ | ------ | -------- |
| 8 bit  | i8     | u8       |
| 16 bit | i16    | u16      |
| 32 bit | i32    | u32      |
| 64 bit | i64    | u64      |
| arch   | isize  | usize    |

부호가 의미하는 것은 음수를 다룰 수 있는지 표현하는 것 (부호가 있으면 음수를 다루는 것)

> 부호된 숫자는 2의 보수 형태를 사용하여 저장됨

각 부호 변수는 -(2^n-1) 부터 2^n-1 -1 까지의 값을 포괄하고

> `i8`일 시 -128부터 127 사이의 값

미부호 타입은 0에서 2^n -1 까지의 값을 포괄함

> `i8`일 시 0에서 255 까지의 값

`isize`, `usize`의 경우 프로그램이 동작하는 컴퓨터 환경에 따라 결정되는데, 환경에 64 bit 아키텍처라면 64 bit의 길이를 사용하고, 32 bit 아키텍처라면 32 bit의 길이를 갖게 됨

### 정수형 리터럴

| Number Literals  | Example     |
| ---------------- | ----------- |
| Decimal (10진수) | 98_222      |
| Hex (16진수)     | 0xff        |
| Octal (8진수)    | 0o77        |
| Binary (2진수)   | 0b1111_0000 |
| Byte (u8 only)   | b'A'        |

byte 리터럴을 제외하고 모든 정수형 리터럴은 시각적인 구분을 위한 `_`의 사용을 허용함

### 어떤 타입의 정수를 사용해야하나?

확실하게 정해진 경우가 아니면 러스트의 기본 값인 `i32`가 일반적으로 좋은 선택

이는 일반적으로 가장 빠르기 떄문이며 심지어 64 bit 시스템에서도 적용되는 사항이다.

> `isize`나 `usize`는 주로 일부 콜렉션 타입의 색인에 사용됨

## 부동 소수점

러스트의 부동 소수점 타입은 두 가지이다.

- f32
- f64

마찬가지로 길이를 32, 64 bit의 크기를 나타냄

기본 타입은 `f64`인데, 최신의 CPU에서는 `f64`가 `f32`와 대략 비슷한 속도를 내면서도 더 정밀한 표현이 가능하기 떄문

```rust
fn main() {
  let x = 2.0 // f64
  let y: f32 = 3.0 // f32
}
```

부동소수점 숫자는 IEEE-754 표준에 따라 표현되며, `f32` 타입은 1배수의 정밀도인 부동소수점이고 `f64`는 2배수의 정밀도인 부동소수점임

> IEEE 754? IEEE에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준.
