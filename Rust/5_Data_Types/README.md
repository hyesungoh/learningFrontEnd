# Data types

러스트의 타입은 크게 **스칼라**와 **컴파운드** 둘로 나눌 수 있음

> 러스트는 타입이 고정된 언어인데, 이것이 의미하는 바는 모든 변수의 타입이 컴파일 시에 반드시 정해져 있어야 한다는 것

## 스칼라 타입

스칼라는 하나의 값으로 표현되는 타입은

- 정수형
- 부동소수점 숫자
- boolean
- 문자

러스트는 위 네 가지 스칼라 타입을 보유하고 있음

### 정수형

소수점이 없는 숫자로써 부호의 여부, 길이로 나뉨

| length | signed | unsigned |
| ------ | ------ | -------- |
| 8 bit  | i8     | u8       |
| 16 bit | i16    | u16      |
| 32 bit | i32    | u32      |
| 64 bit | i64    | u64      |
| arch   | isize  | usize    |

부호가 의미하는 것은 음수를 다룰 수 있는지 표현하는 것 (부호가 있으면 음수를 다루는 것)

> 부호된 숫자는 2의 보수 형태를 사용하여 저장됨

각 부호 변수는 -(2^n-1) 부터 2^n-1 -1 까지의 값을 포괄하고

> `i8`일 시 -128부터 127 사이의 값

미부호 타입은 0에서 2^n -1 까지의 값을 포괄함

> `i8`일 시 0에서 255 까지의 값

`isize`, `usize`의 경우 프로그램이 동작하는 컴퓨터 환경에 따라 결정되는데, 환경에 64 bit 아키텍처라면 64 bit의 길이를 사용하고, 32 bit 아키텍처라면 32 bit의 길이를 갖게 됨

### 정수형 리터럴

| Number Literals  | Example     |
| ---------------- | ----------- |
| Decimal (10진수) | 98_222      |
| Hex (16진수)     | 0xff        |
| Octal (8진수)    | 0o77        |
| Binary (2진수)   | 0b1111_0000 |
| Byte (u8 only)   | b'A'        |

byte 리터럴을 제외하고 모든 정수형 리터럴은 시각적인 구분을 위한 `_`의 사용을 허용함

### 어떤 타입의 정수를 사용해야하나?

확실하게 정해진 경우가 아니면 러스트의 기본 값인 `i32`가 일반적으로 좋은 선택

이는 일반적으로 가장 빠르기 떄문이며 심지어 64 bit 시스템에서도 적용되는 사항이다.

> `isize`나 `usize`는 주로 일부 콜렉션 타입의 색인에 사용됨

### 부동 소수점

러스트의 부동 소수점 타입은 두 가지이다.

- f32
- f64

마찬가지로 길이를 32, 64 bit의 크기를 나타냄

기본 타입은 `f64`인데, 최신의 CPU에서는 `f64`가 `f32`와 대략 비슷한 속도를 내면서도 더 정밀한 표현이 가능하기 떄문

```rust
fn main() {
  let x = 2.0 // f64
  let y: f32 = 3.0 // f32
}
```

부동소수점 숫자는 IEEE-754 표준에 따라 표현되며, `f32` 타입은 1배수의 정밀도인 부동소수점이고 `f64`는 2배수의 정밀도인 부동소수점임

> IEEE 754? IEEE에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준.

### Boolean 타입

러스트에서는 `bool`로 명시됨

```rust
fn main() {
  let t = true;
  let f: bool = false;
}
```

### 문자 타입

#### char

러스트의 `char`은 가장 근본적인 알파벳 타입이며,

`string`이 큰따옴표를 쓰는 것에 반해 `char` 타입은 작은따옴표를 사용함

```rust
fn main() {
  let c = 'z';
  let cat = '😺'
}
```

러스트의 char 타입은 Unicode Scalar를 표현하는 값이고 이는 ASCII 보다 많은 표현을 가능하게 함

> 한국어/중국어/일본어 문자, 이모티콘 넓이가 0인 공백문자 모두 러스트에서는 `char` 타입으로 사용할 수 있음

## 컴파운드 타입

컴파운드(복합) 타입들은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있음

컴파운드 타입 중 기본 타입은 `튜플`과 `배열`

### 튜플

```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 5.4, 1);
}
```

튜플은 단일 요수를 위한 복합계로 고려되어, 튜플 변수에는 튜플 전체가 bind됨

튜플 변수의 개별 값을 밖으로 빼내오기 위해서는 패턴 매칭을 사용해 구조해체하면 됨

```rust
fn main() {
  let tup = (500, 5.4, 1);

  let (x, y, z) = tup;

  println!("y is: {}", y);
}
```

마침표(`.`)를 사용해 튜플의 요소에 직접적으로 접근할 수 있음

```rust
fn main() {
  let tup: (i32, f64) = (500, 5.3);

  let foo = tup.0;

  let bar = tup.1;
}
```

> 대부분의 언어가 그렇듯이 첫 번째 인덱스는 0

### 배열

배열은 튜플과 다르게 배열의 **모든 요소가 같은 타입이여야 함**

러스트의 배열은 고정된 길이를 갖으며, 한번 선언되면 이들의 크기는 커지거나 작아질 수 없음

```rust
fn main(){
  let arr = [1, 2, 3, 4, 5];
}
```

배열이 유용할 때는 데이터를 heap보다 stack에 할당하는 것을 원하거나, 고정된 숫자의 요소를 갖는다고 확신하고 싶을 때임

> 표준 라이브러리에서 제공되는 벡터 타입은 확창 혹은 축소가 가능함, 배열과 벡터 중에 뭘 선택해야 할지 확실하지 않은 상황이라면 벡터를 사용하는 것을 권장함

```rust
fn main() {
  let arr = [1, 2, 3];

  let first = arr[0];
  let second = arr[1];
}
```

배열은 stack에 단일 메모리 뭉치로 할당되고, 인덱스를 통해 배열의 요소에 접근할 수 있음

#### 유효하지 않은 배열 인덱스에 접근 시

```rust
fn main() {
  let arr = [1, 2];
  let index = 10;

  let elem = arr[index];
}
```

만약 배열의 끝을 넘어선 요소에 접근하려고 하면,

컴파일 시에는 아무런 에러가 발생되지 않지만 , 실행 중에 에러가 발생함

- 색인을 사용하여 요소에 접근시에 러스트는 지정한 색인이 배열의 길이보다 작은지 확인함
- 색인이 길이보다 길면 러스트는 프로그램이 오류와 함께 종료 될 때 러스트가 사용하는 용어인 **패닉**을 함

이것은 러스트의 안전 원칙이 동작하는 첫 번째 예임

- 많은 저수준 언어에서 이러한 타입의 검사는 수행되지 않으며 잘못된 인덱스를 제공하면 유효하지 않은 메모리에 엑세스 할 수 있음
- 러스트는 메모리 접근을 허용하고 계속 진행하는 대신 즉시 종료하여 이런 오류로부터 사용자를 보호함
