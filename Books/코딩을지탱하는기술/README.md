# 코딩을 지탱하는 기술

니시오 히로카즈 저의 코딩을 지탱하는 기술을 읽고 중요하다고 생각한 부분을 정리한 문서입니다.

## 효율적으로 언어 배우기

- 비교를 통한 배움

  C 언어에서는 0외의 값이 참이고 0은 거짓이지만, Ruby 에서는 0이 참을 의미한다.
  이처럼 0이 참인 언어, 거짓인 언어, 참도 거짓도 아닌 언어가 존재하며 이와 같은 점을 통해 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다.

- 역사를 통한 배움

  언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습하는 것을 의미한다. 이를 통해 언어가 가지고 있는 다양한 기능이 '왜' 탄생했는지 배울 수 있다.

## 프로그래밍 언어 탄생의 역사

- ENIAC (Electronic Numerical Integrator and Computer)

  폭이 24미터가 되는 컴퓨터로 프로그래밍을 하기 위해서 수많은 단자에 케이블을 여기저기 연결해야했다.

- EDSAC (Electronic Delay Storage Automatic Computer)

  1949년 개발된 컴퓨터로써, 기존의 케이블을 연결하는 문제점을 해소하고자 테이프에 구멍을 뚫어서 데이터를 표현하고 컴퓨터가 이를 읽어 들이도록 한 구조다.
  작업이 수워해졌다고는 하지만, 사람이 프로그램을 일거나 쓰는 것은 여전히 어려웠다. 입력에 사용하는 종이 테이프는 하나에 열에 최대 5개의 구멍만으로 프로그램을 표현해야 했기 때문이다.

- FORTRAN

  1954년 지금의 프로그래밍 언어와 비슷한 FORTRAN이 고안되었다. 초기 FORTRAN 컴파일러가 출력하는 기계어는 능숙한 프로그래마가 짠 기계어에 비교하면 효율이 매우 떨어졌다고 한다. 하지만 코드량이 눈에 띄게 줄었고 코드를 읽기 쉬워짐에 따라 많은 사용층을 얻을 수 있었다고 한다.

## 프로그래밍 언어 탄생의 목적

Perl 설계자 Larry Wall은 자신의 저서에 프로그래머가 가져야 할 3가지 자질로서 `나태`, `조바심`, `자만심`을 제안하였다.

- 나태

  전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기징.

  노동력을 줄이기 위해 만든 프로그램은 다른 사람들도 사용하게 되며, 질문에 일일이 답한느 수고를 덜기 위해 문서를 만들게도 된다.

- 조바심

  프로그램이 느린 것을 용납하지 않는 것

- 자만심

  틀린 것을 방치하지 않음을 의미F

#### 무엇을 편하게 하고 싶은 것인가

- C++ : 빠른 실행 속도를 중시
- Scheme : 언어 사양을 쉽게 파악할 수 있는 데 중시
- Python : 코드를 쉽게 읽을 수 있는 데 중시

프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 하지만 무엇이 편한지는 언어에 따라 다르다.

프로그래밍 언어는 도구다. 어떤 도구가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다. 좋은 도구를 현명하게 선택하여 적재적소에 사용하도록 하자.

## 문법의 탄생

"1 더하기 2에 3을 곱한다"는 똑같은 처리도 언어에 따라 표현 방법이 틀리다. 그러나 구문 틀리로 표현하면 거의 동일한데 이들 언어에 차이가 생긴 것은 어떤 문자열을 쓰면 어떤 구문 트리가 생긱는가라는 규칙이다. 이것이 문법이다.

`FORTH`, `LISP`는 규칙이 적은 것을 중시하였으나 시장이 요구한 것은 규칙이 적거나 간단한 것이 아니었다.

FORTRAN 처럼 \*가 +보다 우선 순위가 높다 등의 정해진 규칙을 대량으로 도입해서 다가가기 쉬운 작성법을 중시했다.

> 현재 대부분의 프로그래밍 언어는 FORTRAN식의 "다가가기 쉬운 작성법"을 목표로 하고 있다.

하지만 모순 없이 해석할 수 있는 문법을 만들어내는 것은 어려운 작업이다. 이 때문에 현실의 프로그래밍 언어에는 이해하기 어려운 작성법이 여전히 존재한다.

## 처리 흐름 제어

#### If

어셈블리어는 if, else if, else 없이 동작한다. 이는 조건을 비교 후 C 언어의 `goto`처럼 점프하는 방식으로 동작하게 된다.

#### While

while 문도 마찬가지로 어셈블리어에서는 점프를 통해 구현하고 있다.

#### For

for 문으로 작성 가능한 것은 while 문으로도 작성 가능하다.

하지만 여러 곳에 나누어져있는 코드를 한 곳에 정리하야 루프의 의도를 쉽게 이해할 수 있다.

#### Foreach

while은 조건식으로 반복을 제어, for 문은 횟수로 반복을 제어, foreach는 처리 대상으로 반복을 제어한다.

#### 정리

위에서 언급한 처리 흐름 제어 구문으로 사용하지 않아도 프로그램을 짤 수 있다. 그러나 사용하는 것이 보다 알기 쉬운 코드를 구성할 수 있고, 그걸 위해 개발되었다.

## 함수

위 처리 흐름 제어문처럼 goto만을 이용해서는 함수를 구현하기 어렵다.

이는 원래 위치로 돌아가는 것의 부재 때문인데, 이를 위해 돌아가야하는 곳을 저장하는 메모리를 만들어 사용하고 있다.

> 이는 레지스터에 위치

또한 함수 안에서 함수를 호출하는 경우를 위해 스택으로 구현되어 있다.

#### 해결하고자 한 것

프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다. 또한 비슷한 처리를 몇 번이고 반복해서 쓰고 싶어지는 경우도 생길텐데, 해당 문제를 해결하기 위해 한 그룹인 코드를 빼내어 의미 있는 이름을 붙여서 해결하는 것을 우리가 알고 있던 함수라고 칭한다.

또한 내포 구조로된 데이터를 다루기 적합한 재귀 호출이라는 방법도 함수를 사용함으로써 탄생하게 되었다.

## 에러 처리

에러 처리르 구현하는 방법은 크게 2가지가 있다.

#### 반환값으로 실패를 전달

```c
// C
if(func()) {
  // error handling
}
```

에러 처리 구문이 존재하지 않는 C 언어의 경우 다음과 같은 방법으로 에러 처리를 하게 되는데 이는 **실패를 놓칠 수 있다**와 **에러 처리 떄문에 코드를 해석하기 어렵다**는 단점을 가지고 있다.

이를 해결하기 위해서 **점프로 에러 처리를 정리**하는 방법이 있다.

```c
// C
int main() {
  if (!func("A")) goto ERROR;
  if (!func("B")) goto ERROR;
  if (!func("C")) goto ERROR;
  return;
}
ERROR:
  // Error Handling
```

#### 실패하면 점프

위 기법은 C 언어 중심으로 지금도 자주 사용되고 있는데, C 언어가 나오기 한참 전부터 다른 방법의 에러 처리가 존재했다. 이는 **에러가 발생했을 때 점프할 장소를 사전에 등록해두는 방법**이다.

- UNIVAC I

실은 에러가 발생했을 때 점프한다는 발상은 프로그래밍 언어보다 먼저 존재했다.

1950년에 만들어진 컴퓨터 UNIVAC I에는 계산 시 오버플로우가 발생하면 XXX번지에 있는 명령을 실행한다는 기능이 있었다. 이런 기능을 **인터럽트**라고 불렀으며 현재에도 에러 처리뿐만 아니라 다양한 목적으로 사용되고 있다.

> 예를 들어 키보드 키가 눌렸을 때 CPU에게 알리기 위해

- COBOL

1954년 등장한 FORTRAN에는 예외 처리가 없었지만 1959년 등장한 COBOL에는 2 가지 에러 처리가 준비되어 있었다.

이는 2가지 에러 처리를 위해 별도의 구문이 사용되는 방식이였다.

- PL/I

1964년 등장한 프로그래밍 언어 PL/I의 경우 FORTRAN, COBOL, ANGOL을 집성해서 설계되어 유연하고 통일된 에러 처리를 위해서 ON 구문을 도입하였다.

```PL/I
/* PL/I */
SHORI: procedure;
  on error go to ERROR;
  call func(1);
  call func(2);
  call func(3);
  return;
  ERROR:
  <Error handling>;
end;
```

> C 언어 코드에서는 if문으로 반환값을 체크하고 있었지만 여기서는 체크가 없어졌다.

또한 새롭게 정의한 실패를 프로그래머가 발생시킬 수 있었다.

#### 실패할 것 같은 처리를 묶는 구문

PL/I 구문은 '미리 실패했을 때 처리를 등록해둔 후 실패할 것 같은 코드를 쓰는' 형식이다. 하지만 최신의 프로그래밍 언어세너느 실패할 것 같은 코드를 미리 try로 묶어둔 후 실패했을 때 처리를 쓰는 형식이다.

- John Goodenough

1975년에 John Goodenough는 자신의 논문에서 보다 좋은 예외 처리 방법을 제안했다.

> 그 내용은 '프로그래머는 명령이 예외를 던질 가능성이 있다는 것을 잊어버리고 최적이 아닌 장소 또는 최적이 아닌 종류의 예외 처리를 사용하는 등의 실수를 할 가능성이 있다. 이 가능성을 줄이고 프로그래머가 한 실수를 컴파일러가 경고하도록 하기 위해서는 2가지가 필요하다. 하나는 **명령이 어떤 예외를 던질 가능성이 있는지를 명시적으로 선언**하는 것이다. 다른 하나는 **자발적으로 실패할 것 같은 처리를 묶는 구문**이다.'

여기서 제안된 묶는 구문이 현재 대부분의 언어가 채용하고 있는 실패할 것 같은 처리를 묶은 후 에러 처리를 나중에 기술하는 구문의 시초가 되었다.

- CLU

75년부터 77년 사이 프로그래밍 언어 CLU는 예외 처리 메커니즘을 도입했다. 이 때 추가된 것이 명령 뒤에 에러 처리를 쓰는 **except** 구문이었다.

```CLU
begin
  % 실패할 것 같은 처리
end except when 실패 종류:
  % 실패했을 때 처리
end
```

- C++

83년에 등장한 C++은 84년부터 89년까지 예외 처리에 관한 여러 논의 끝에 **try, catch** 구문을 추가했다.

> C++의 설계자 Bjarne Stroustrup에 따르면 try는 알기 쉽게 하기 위한 장치다.

```c++
try {
// 실패할 것 같은 코드
} catch {
// 실패했을 때 처리
}
```

또한 예외를 발생시키기 위한 명령으로 **throw**라는 용어가 만들어졌다.

> PL/I나 CLU에서 사용되던 signal을 사용하지 않은 이유는 이미 다른 라이브러리에서 사용되고 있었기 때문이다. 이런 연유로 실패를 발생시키는 것을 예외를 던지는 것으로 표현한 계기가 되었다.

- Windows NT 3.1

93년 경에 windows NT 3.1이 공개되었는데 이 때 구조화 예외에 **finally** 키워드가 도입되었다.

- 왜 finally를 도입했을까?

Microsoft사는 구조화 예외 처리를 채용함으로 코드의 신뢰성을 높일 수 있었다고 답하였다. 예를 들어 프로그래머가 예측하지 못한 종료가 발생했을 시 메모리 블록이나 파일 등의 리소스를 잘 닫을수 있게 된다고 하였다.

이를 이용해 짝이되는 처리를 finally를 사용하여 작성할 수 있다.

```java
// java
try {
// 실패할지도 모르는 코드
} catch(...) {
// 예외 처리 코드
} finally {
// 반드시 실행되는 코드
}
```

```python
try:
  # 실패할지도 모르는 코드
except:
  # 예외 처리 코드
finally:
  # 반드시 실행되는 코드
```

반면, C++은 finally를 가지고 있지 않다. 그렇기 때문에 C++ dptjsms RAII(Resource Acquisition Is Initialization)라는 기술을 사용하는 것이 일반적이다.

> 예를 들어 파일을 열었다가 닫는 환경이라면 클래스의 생성자에서 열어서 소멸자에서 닫는다.

- D 언어

01년에 C++보다 개선하자는 목표를 가지고 등장한 D 언어는 RAII가 세련됐다는 의견에 반대하여 scope라는 개념을 도입하여 스코프 가드를 사용하여 미리 벗어날 때 할 처리를 등록할 수 있다.

```D
void func(){
  Mutex m = new Mutex;

  lock(m);
  scope(exit) unlock(m);
}
```

- Java의 검사 예외

Java 개발팀은 어떤 예외를 던질지에 대한 문제를 해결하기 위해 '검사 예외'를 도입하였다. 하지만 그다지 환영받고 있지 않은 방법이 되었고 C# 개발팀은 검사 예외를 인정하면서 보다 나은 구현 방법을 요구하고 있다.

#### 정리

실패를 전달하는 방법으로 크게 `반환값으로 알린다`, `실패하면 점프한다` 2가지로 나뉘며 해당 방법에는 각각 반환값을 확인하는 것을 잊어버리는 문제, 함수의 출구가 여러개로써 짝을 이루는 처리를 바르게 처리하는 것이 어렵다는 문제가 있다.

결국에 두 방법을 잘 파악한 후 적재적소에 사용하는 것이 중요하다고 기술되어있다.
