# 데이터 타입

## 데이터 타입의 종류

### 기본형 (원시형, primitive type)

- 숫자
- 문자열
- 불리언
- null
- undefined
- Symbol

### 참조형 (reference type)

- 객체
  - 배열
  - 함수
  - 날짜
  - 정규표현식
  - Map, WeakMap
  - Set, WeakSet

일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있다.

다만 기본형은 값이 담긴 주솟값을 바로 복제하지만, 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

## 데이터 타입에 관한 배경지식

자바스크립트는 메모리 용량이 과거보다 월등히 커진 상황에 등장하여 상대적으로 메모리 관리에대한 압박에서 자유롭다.

숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 8 바이트 (64비트)를 확보한다.

- 이 중 1비트는 부호, 11비트는 지수부, 나머지 52비트를 가수부로 사용함

### 식별자와 변수

변수 : 변할 수 있는 수 (변할 수 있는 무언가)

식별자 : 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**

## 변수 선언과 데이터 할당

```js
var a;
```

위 코드를 통해 컴퓨터는 메모리에서 비어있는 공간 하나를 확보한다.

그리고 그 공간의 이름(식별자)를 a라고 지정한다.

이후 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환한다.

### 데이터 할당

```js
var a = "abc";
```

위 코드는 아래처럼 동작한다.

1. 변수 영역에서 빈 공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 "abc"를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다(@1003).
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

왜 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 거치는 것일까 ?

- **데이터 변환을 자유롭게 할 수 있게 함**

만약 문자열이 길어지는 변경이 일어날 때

맨 뒤의 메모리에 있다면 늘리기만 하면 되겠지만, 중간에 있다면 해당 공간보다 뒤에 저장된 데이터들을 전부 옮기고

옮긴 주소를 각 식별자에 다시 연결하는 작업을 해야함

곧 연산이 많아질 수 밖에 없음

- **메모리를 더욱 효율적으로 관리하기 위해**

현재 문자열 'abc'에 변경이 일어난다면 해당 문자열을 **새로 만들어 별도의 공간에 저장**하고 그 주소를 변수 공간에 연결함

다른 예로 변수 500개에 같은 값인 '5'를 할당하는 상황이라고 할 때,

각 변수 공간마다 숫자 5를 할당한다면 숫자형은 8바이트이니 총 4000 (500 \* 8) 바이트가 필요함

근데 5를 별도의 공간에 저장하고 해당 주소만 입력한다면 주소 공간의 크기가 2바이트라고 한다면 1008 (500 \* 2 + 8) 바이트만 이용하면 됨

이처럼 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐

## 기본형 데이터와 참조형 데이터

변수와 상수를 구분 짓는 변경 가능성의 대상은 `변수 영역` 메모리이다.

반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 `데이터 영역` 메모리이다.

> 기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.

```js
var a = "abc"; // 데이터 영역에 abc를 찾고, 없으니 만든다. 이후 변수 영역에 해당 주소를 할당한다.
a = a + "def"; // 데이터 영역의 변환이 있는 것이 아닌, abcdef를 찾고 없으니 만든다. 이후 변수 영역에 해당 주소를 할당한다.

var b = 5; // 마찬가지로 찾은 후 데이터 영역에 공간을 만들고 변수 영역에 해당 주소를 할당한다.
var c = 5; // 찾기를 성공하여 해당 데이터 영역 주소를 새로운 변수 영역에 할당한다.
b = 7; // 새로운 데이터 영역에 할당하고, 변수 영역의 주소를 바꾼다.
```

### 참조형 데이터를 변수에 할당하는 과정

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
```

1. 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니, 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다.
   이 그룹의 내부 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고 그 영역의 주소(@7103 ~ ?)를 @5001에 저장
3. @7103 @7104에 각각 a와 b라는 프로퍼티 이름을 지정
4. 데이터 영역에서 숫자 1을 검색 > 결과가 없으니 임의로 @5003에 저장 > 이 주소를 @7103에 저장.
   마찬가지로 'bbb'도 동일한 순서로 진행

기본형 데이터와의 차이는 '객체의 변수 영역'이 별도로 존재한다는 점

- 데이터 영역에 저장된 값은 모두 불변값

### 변수 복사 비교

**기본형**

```js
var a = 10;
var b = a;
```

1. 변수 영역의 빈 공간 @1001를 확보하고 식별자를 a로 지정
2. 데이터 영역에서 10을 찾고, 없으므로 빈 공간 @5001에 저장
3. @5001을 @001에 할당

4. 변수 영역의 빈 공간 @1002를 확보하고 식별자를 b로 지정
5. 식별자 a를 검색
6. @1001에 저장된 값인 @5001을 @1002에 값으로 대입

**참조형**

```js
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

1. 변수 영역의 빈 공간 @1003을 확보하고 식별자를 obj1로 지정
2. 데이터 영역의 빈 공간 @5002를 확보하고 데이터 그룹이 담겨야 하기 때문에 별도의 변수 영역 @7103 ~을 확보하고 그 주소를 저장
3. @7103에는 식별자 c를, @7104에는 식별자 d를 입력
4. c에 대입할 값 10을 데이터 영역에서 검색하고 @7103에 대입
5. d에 대입할 값 'ddd'를 데이터 영역에서 검색하고 없으니 새로 만들어서 @7104에 대입

6. 변수 영역의 빈 공간 @1004를 확보하고 식별자를 obj2로 지정
7. 식별자 obj1을 검색
8. @1003에 저장된 값인 @5002를 @1004에 값으로 대입

복사 과정은 동일하지만 변수 복사 이후의 동작에 큰 차이가 발생함

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

`b = 15;`에서는 데이터 영역에 15가 없으므로 새로 저장하고, 그 주소를 식별자 b에 저장함

`obj2.c = 20;`에서는 마찬가지로 데이터 영역에 20이 없으므로 새로 저장하고,
그 주소를 든 채로 변수 영역에서 obj2를 찾고, obj2의 값인 @5002가 가리키는 변수 영역에 다시 c를 찾아
그 곳에 대입함

즉, 변수 a와 b는 서로 다른 주소를 바라보나, obj1과 obj2는 여전히 같은 객체를 바라보고 있는다.

```js
a !== b;
obj1 === obj2;
```

```
어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 떄문에

엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없다.

다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 되는 차이
```

> 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립함

## 불변 객체

```js
// 불변 객체가 필요한 경우

var user = {
  name: "hyesung",
  gender: "male",
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser;
};

var user2 = changeName(user, "foo");

console.log(user.name, user2.name); // foo foo
```

위 예제에서는 user와 user2 두 객체가 같은 주소를 바라보고 있기 때문에 불변 객체가 아니다.

서로 다른 객체를 바라보게 만들면 아래와 같다.

```js
var user = {
  name: "hyesung",
  gender: "male",
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender,
  };
};

var user2 = changeName(user, "foo");

console.log(user.name, user2.name); // hyesung foo
```

새로운 객체를 반환하기 때문에 같은 주소를 바라보고 있지 않는다.

하지만 `gender` 같은 프로퍼티가 많을 시 하드코딩 되어야 하고, 이를 수정하기 위해서는 얕은 복사를 하는 함수를 만들어 사용할 수 있다.

### 얕은 복사와 깊은 복사

얕은 복사는 바로 아래 단계의 값만 복사하는 방법

깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법

즉 얕은 복사 시에 중첩된 객체가 존재할 시 새로운 객체가 아니라 주소값을 복사한다. (변경에 자유롭지 못하다)

```js
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};

var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }

  return result;
};
```

깊은 복사 시에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않는다.

> ES5의 getter/setter를 복사하는 방법은 ES6의 `Object.getOwnPropertyDescriptor` 또는 ES2017의 `Object.getOwnPropertyDescriptors` 외에는 마땅한 방법이 없다.

## undefined와 null

자바스크립트 엔진은 다음 세 경우에 undefined를 반환한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

```js
var a;
console.log(a); // (1)

var obj = { a: 1 };
console.log(obj.b); // (2)

var func = function () {};
var c = func();
console.log(c); // (3)
```

### empty와 undefined

empty, 즉 비어있는 요소는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.

> 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타낸다.

```
var a;
console.log(a); // (1)

위 예제에서는 자바스크립트가 직접 undefined를 할당한다.
이유는 var로 선언한 변수는 생성되면서 동시에 undefined로 초기화되기 때문이다.

한편 let과 const는 undefined를 할당하지 않은 채로 초기화를 마치며,
이후 특정 값을 할당하기 전가지는 해당 변수에 접근할 수 없다.
```

### null

typoef null은 object 이다.

```js
var n = null;

console.log(typeof n); // object;

n == undefined; // true
n == null; // true

n === undefined; // false
n == null; //true
```

## 정리

- 자바스크립트 데이터에는 크게 기본형과 참조형이 있고, 기본적으로 기본형은 불변값이고 참조형은 가변값이다.
- 변수는 변경 가능한 데이터가 담길 수 있는 공간이고, 식별자는 그 변수의 이름을 말한다.
- 기본형 데이터인 변수를 선언하면 데이터 영역에 저장하고 그 공간의 주소를 변수의 값 영역에 할당한다.
- 참조형 데이터는 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 확보된 주소를 변수에 연결하고,
  다시 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장하고,
  각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다.

> 이처럼 할당 과정에서 기본형과 차이가 생긴 이유는 참조형 데이터가 여러 개의 프로퍼티를 모은 '그룹'이기 때문이다.
> 그리고 이 차이로 인해 참조형 데이터를 '가변값'으로 여겨야만 하는 상황이 발생한다.

- 참조형 데이터를 불변값으로 사용하는 방법은 깊은 복사를 하면 된다.
- 없음을 나타내는 값은 두 가지가 있는데, undefined와 null이다.
  없음을 표현하기 위해서 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다.
