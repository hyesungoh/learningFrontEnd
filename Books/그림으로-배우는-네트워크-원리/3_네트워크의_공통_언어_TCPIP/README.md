# 네트워크의 공통 언어 TCP/IP

## 네트워크의 공통 언어

* 지금은 대부분 TCP/IP만 사용됨
* 네트워크 인터페이스층, 인터넷층, 트랜스포트층, 애플리케이션층, 총 4계층으로 구섬됨

## 데이터를 전송하는 역할을 하는 계층

* 네트워크 인터페이스층의 역할은 같은 네트워크 안에서 데이터를 전송하는 것
  + 하나의 네트워크는 라우터와 레이어3 스위치로 구획되는 범위 / 또는 레이어2 스위치로 구성하는 범위

* 네트워크 인터페이스층의 구체적인 프로토콜
  + 유선(이더넷)
  + 무선 LAN(Wi-Fi)
  + PPP
  + 통신 상대와 같아야 할 필요는 없음

* 인터넷층
  + 한 네트워크에 모든 기기가 연결되는 것은 아님
    - 많은 네트워크가 존재하고 거기에 다양한 기기가 연결
    - 인터넷층은 그 네트워크 사이에서 데이터를 전송하는 역할

  + 네트워크끼리 연결하고 데이터를 전송하는 기기가 라우터
    - 라우터에 의한 전송을 가리켜 라우팅

  + IP, ICMP, ARP 등의 프로토콜
    - 엔드투엔드 통신에 이용하는 프로토콜이 IP이고 ICMP와 ARP는 IP를 도와주는 프로토콜

## 애플리케이션의 동작을 준비하는 계층

* 트랜스포트층
  + TCP, UPD
  + TCP는 신뢰성을 확보

* 애플리케이션층
  + 애플리케이션에서 다루는 데이터 형식과 처리 순서등을 결정

## 데이터 송수신 규칙

* 각 프로토콜의 처리를 하기 위한 제어 정보를 헤더라고 함
  + 캡슐화와 역캡슐화

* 웹브라우저에서 웹서버로 데이터 전송하는 모습
  + 웹브라우저의 데이터는 우선 HTTP 헤더로 캡슐화되어 TCP로
  + TCP 헤더 추가
  + IP 헤더 추가
  + 마지막으로 이더넷 헤더와 FCS(Frame Check Sequence)가 추가
  + FCS는 에러 체크를 위한 정보

## 데이터 수신, 전송할 때의 규칙

* 수신하는 모습
  + 물리 신호가 도착하면 0과 1의 데이터로 변환
  + 이더넷 헤더를 참조해 자기 앞으로 온 데이터인지 확인
  + FCS를 이용해 오류가 없는지 확인
  + 자기 앞으로 왔으며, 오류가 없다면 위 두개 헤더를 제거하고 IP 헤더 처리로 넘김
  + IP 헤더를 참조해 자기 앞으로 온 데이터인지 확인하고 TCP 헤더 처리로 넘김
  + TCP 헤더를 참조해 어느 애플리케이션의 데이터인지 확인
  + 애플리케이션에서 HTTP 헤더와 데이터 부분을 알잘딱 처리

## 데이터를 부르는 방법은 다양하다

* 웹브라우저 통신의 경우
  + HTTP 헤더를 추가한 데이터: HTTP 메시지
  + TCP 헤더를 추가하면: TCP 세그먼트
  + IP 헤더를 추가하면: IP 패킷
  + 이더넷 헤더와 FCS를 추가하면: 이더넷 프레임

## 데이터를 목적지까지 전송한다

* IP
  + 인터넷 프로토콜
  + 엔드투엔드 통신을 하기 위함

* 목적지가 다른 네트워크에 있을 때는 경로 상에 있는 라우터가 IP 패킷을 라우팅함

## 통신 상대는 누구?

* IP 헤더에는 목적지 IP 주소와 출발지 IP 주소가 지정돼야만 함

* IP는 인터페이스마다 설정할 수 있음
  + 유선 랜과 무선 인터페이스
  + 즉, 정확하게는 호스트 자체가 아니라 호스트의 인터페이스를 식별

* 32비트임
  + 8비트 10진수 4개로 표현

## 목적지는 하나? 아니면 여러 개?

* 유니캐스트
  + 목적지가 단 한 곳
  + 완전히 같은 데이터를 여러 곳에 보내기 위해 여러번 유니캐스트 전송을 반복하면 되지만 효율이 안좋음

* 브로드캐스트
  + 같은 네트워크 상의 모든 호스트에 완전히 똑같은 데이터를 전송
  
* 멀티캐스트
  + 특정 그룹에 포함되는 호스트에 완전히 똑같은 데이터를 전송

## IP 주소의 구성은 크게 나눠 두 가지

* 네트워크부 호스트부
  + 네트워크부는 네트워크를 식별
  + 호스트부는 네트워크 내의 호스트(의 인터페이스)를 식별

* 브로드캐스트 주소는 `255.255.255.255`
  + 호스트부의 모든 비트가 1인 IP 주소도 포함

* 멀티캐스트 주소는 범위가 지정돼 있음
  + `224.0.0.0` ~ `239.255.255.255`

## IP 주소의 범위 구분

* 네트워크부, 호스트부의 구분은 고정된 게 아니라 가변적
  + 이를 명시한 것이 서브넷 마스크

* 8비트 10진수로 표현
  + 1이 네트워크부를 의미함

* / 뒤에 연속한 1의 개수를 표시하는 프리픽스 표기도 있음

## 네트워크에 접속하는 두 단계

* 네트워크에 접속하기 위해서는 물리적인 접속과 논리적인 접속이 필요

* 물리적인 접속은 랜 케이블 삽입 등 물리적인 신호를 주고받을 수 있게 하는 것

* 논리적인 접속은 인터페이스에 IP 주소를 설정하는 것
  + DHCP 등의 기술로 자동으로 설정하게 함

## 인터넷에서 사용하는 주소와 사설 네트워크에서 사용하는 주소

* 공인 IP 주소
  + 인터넷 전체에서 중복되지 않음
* 사설 IP 주소
  + 사설 네트워크에서 이용하는 주소

## 사설 네트워크에서 인터넷으로의 통신

* 인터넷에서는 목적지가 사설 주소로 된 IP 패킷은 반드시 폐기됨

* 사설 네트워크에서 인터넷으로 통신하기 위해서는 NAT로 주소를 변환
  + 출발지 IP 주소를 변환
  + 라우터는 원래대로 되돌리기 위해 변환한 주소의 대응을 NAT 테이블에 보존해 둠
  + 요청에 대한 응답이 라우터로 돌아오면 주소를 변환

## 데이터가 목적지에 잘 도착했을까?

* 최선형
  + IP는 '데이터를 보내기 위해 최선은 다하지만, 안되도 어쩔 수 없지'라는 특징을 가짐

* ICMP
  + 정상적으로 이루어졌는지 확인하는 프로토콜
  + 에러 리포트
    - 폐기한 기기가 ICMP를 이용해 출발지로 에러 리포트를 보냄
  + 진단 기능
    - 통신이 가능한지 확인 (ping)

## IP 주소와 MAC 주소를 대응시킨다

* PC나 서버 등의 인터페이스는 MAC 주소로 식별함
  + TCP/IP의 IP 주소와 인터페이스를 식별하기 위한 MAC 주소를 대응시키는 것이 ARP의 역할

* 이더넷 헤더를 붙일 때, 목적지 MAC 주소를 지정해야 함
  + 이떄 ARP를 이용해 주소 해석을 함
    - IP 주소와 MAC 주소를 대응시키는 것

* ARP 동작 흐름
  + ARP 요청을 브로드캐스트해 물어봄
  + 대상이 자신이라면 MAC 주소를 반환, 수신 상대도 ARP 캐시를 갱신
  + 응답을 받은 후 캐시를 갱신

## 포트 번호로 애플리케이션에 할당

* 호스트에서 동작하는 애플리케이션에 데이터를 배분하기 위해서는 각각의 애플리케이션을 식별할 수 있어야 함
  + 이 떄 포트 번호가 사용됨
  + TCP or UDP 헤더에 지정함

* 웰노운 포트
  + 미리 정해져 있는 포트 번호
  + HTTP 80, HTTPS 443, SMTP 25 등

## 확실하게 애플리케이션의 데이터를 전송한다

* TCP
  + 이를 이용하면 애플리케이션 프로토콜에는 신뢰성을 확보하기 위한 구조를 넣어 둘 필요가 없음

1. TCP 커넥션 맺기 (3웨이 핸드쉐이크)
  + 데이터를 송수신하는 애플리케이션 간의 통신이 정상적으로 이루어질 수 있는지 확인

2. 애플리케이션 간 데이터 송수신
  + TCP 헤더 추가 (TCP 세그먼트)
  + 데이터 크기가 크면 분할하여 전송함
  + 어떻게 분할했는지는 TCP 헤더에 기술되고, 목적지에서 차례대로 원본 데이터로 조립
  + 데이터 수신 확인 (ACK라고 부름)
  + 일부 데이터가 제대로 도착하지 않았다면 재전송함
  + 네트워크가 혼잡하면 전송 속도를 제한 (플로우 제어)

3. TCP 커넥션 끊기

## TCP로 데이터를 분할한다

* 시퀸스 번호
  + 데이터 순서를 나타냄

* ACK 번호
  + 수신했음을 확인하기 위해 이용함

* MSS (Maximum Segment Size)
  + 한 번에 전송할 수 있는 데이터의 최대 크기
  + 1460 바이트
  + 이보다 큰 데이터는 분할하여 전송
    - 이더넷의 MTU(Maximum Transmission Unit)이 1500 바이트
    - IP 헤더 20바이트, TCP 헤더 20바이트

## 애플리케이션에 데이터를 배분하기만 한다

* UDP
  + TCP가 하는 처리를 하지 않아, 데이터 전송 효율이 좋음
  + 크기가 큰 데이터를 분할하는 기능 없음

* 실시간 데이터 전송이 필요할 떄 사용
  + IP 전화, 스트리밍 등

## 네트워크의 전화번호부

* 사용자가 이해하기 쉬운 이름인 호스트명(URL 등)을 사용

* 호스트 이름에 대응하는 IP 주소를 구하는 것이 DNS
  + 이름 해석이라함

## DNS로 IP 주소를 자동으로 구한다

* DNS 서버에는 호스트명과 IP 주소의 대응 관계에 더해서 여러 가지 정보를 등록함
  + 리소스 레코드
  + A 레코드: 호스트명에 대응하는 IP주소
  + AAAA 레코드: 호스트명에 대응하는 IPv6 주소
  + CNAME: 호스트명에 대응하는 별명
  + NS: 도메인명을 관리하는 DNS 서버

* DNS 리졸버
  + DNS 서버에 질의하는 기능 (OS에 내정)

* DNS 캐시
  + DNS 서버와 리졸버는 질의한 정보를 한동안 캐시에 보관

* 이름해석 예
  + 루트에서부터 질의를 반복
  + `www.example.com`이라면
    - 루트: com DNS 서버의 IP 주소를 알아냄
    - com: example.com DNS 서버의 IP 주소를 알아냄
    - example.com: www.example.com의 IP 주소를 알아냄

## 필요한 설정을 자동화한다

* TCP/IP 설정을 자동화하는 프로토콜은 DHCP
  + TCP/IP 설정 항목

* DHCP
  + DHCP 클라이언트는 아무것도 몰라서 브로드캐스트를 이용함
  
