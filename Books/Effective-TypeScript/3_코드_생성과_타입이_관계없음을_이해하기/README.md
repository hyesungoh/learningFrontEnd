# 코드 생성과 타입이 관계없음을 이해하기

## 타입스크립트 컴파일러는 크게 두 가지 역할을 수행

- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전 자바스크립트로 트랜스파일함
- 코드의 타입 오류를 체크함

위 두 가지가 서로 완벽히 독립적으로 실행됨

이를 통해 타입스크립트가 할 수 있는 일, 없는 일을 알 수 있음

## 타입 오류가 있는 코드도 컴파일이 가능

타입스크립트는 타입 오류가 있어도 컴파일이 가능함

> 타입 체크와 컴파일이 동시에 이뤄지는 C나 자바와 같은 언어와 달리 타입스크립트의 오류는 다른 언어의 경고와 비슷함. 문제가 될 부분은 알려주지만 빌드를 멈추진 않음

문제가 되는 부분을 수정하지 않아도 다른 부분을 테스트할 수 있는 의도적인 선택

오류가 있을 때 컴파일하지 않으려면 `noEmitOnError`를 설정해 적용할 수 있음

## 런타임에는 타입 체크가 불가능

```tsx
interface Foo {
  foo: number;
}

interface Bar {
  bar: string;
}

type Baz = Foo | Bar;

function something(some: Baz) {
  if (some instanceof Foo) {
  }
}
```

`instanceof` 체크는 런타임에 일어나지만, 비교 대상인 `Foo`는 타입이기 때문에 런타임 시점에는 아무런 역할을 할 수 없음

타입스크립트의 타입은 제거 가능하기 때문인데, 실제로 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되기 때문

위 코드를 명확히 할려면 `속성이 존재하는 지 확인`하는 방법,

런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 태그 기법,

```ts
interface Foo {
  kind: 'Foo';
}

interface Bar {
  kind: 'Bar'
}

//...
if (some.kind === 'Foo')
```

타입을 클래스로 만드는 방법이 있음

```ts
class Foo {
  constructor(public width: number) {}
}

type Baz = Foo | Bar

// ...
if (some instanceof Foo)
```

> `type Baz = Foo | Bar`에서는 타입으로 참조되지만, `some instanceof Foo`에서는 값으로 참조됨. 어떻게 참조되는지 구분하는 건 중요하며 아이템 8에서 다룰 예정

## 타입 연산은 런타임에 영향을 주지 않음

## 런타임 타입은 선언된 타입과 다를 수 있음

대표적으로 AJAX 응답 값을 사용할 때 선언된 타입과 다를 수 있음

선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 함

## 타입스크립트 타입으로는 함수를 오버로드할 수 없음

지원하기는 하지만, 온전히 타입 수준에서 동작함

**즉, 선언문을 여러 개 작성할 수 있지만 구현체는 오직 하나뿐**

> 아이템 50에서 주의사항을 다룰 예정

## 타입스크립트 타임은 런타임 성능에 영향을 주지 않음

타입과 타입 연산자는 자바스크립트로 변환 시점에서 제거되기 때문에 런타임에는 아무런 영향을 주지 않음

즉, 런타임 오버헤드가 없음. 하지만 빌드타임 오버헤드가 있음

