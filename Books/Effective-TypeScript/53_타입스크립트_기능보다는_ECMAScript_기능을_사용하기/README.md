# 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

타입스크립트가 태동하던 2010년경에는 자바스크립트는 결함이 많고 개선해야 할 부분이 많은 언어였다.

시간이 흘러 자바스크립트는 부족했던 점들 대부분을 내장 기능으로 추가했는데, 타입스크립트 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시켰다.

그래서 타입스크립트 진영에서는 다음 전략 중 하나를 선택해야만 했다.

- 타입스크립트 초기 버전의 형태를 유지하기 위해 자바스크립트 신규 기능을 변형해서 끼워 맞추는 것
- 자바스크립트의 신규 기능을 채택하고 타입스크립트 초기 버전과 호환성을 포기하는 것

타입스크립트 팀은 대부분 두 번째 전략을 선택했다.

이를 통해 TC39(자바스크립트를 관장하는 표준 기구)는 런타임 기능을 발전시키고, 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지켜오고 있다.

그런데 이 원칙이 세워지기 전에 이미 사용되고 있던 몇 가지 기능이 있다.

이 기능들은 타입 공간과 값 공간의 경계를 혼란스럽게 만들기 때문에 사용하지 않는 것이 좋다.

## 열거형

```ts
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
```

타입스크립트의 열거형은 아래 목록처름 상황에 따라 다르게 동작한다.

- 숫자 열거형(위 예제)에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험하다 (이 방법은 원래 비트 플래그 구조를 표현하기 위해 설계되었다)
- 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다.
  앞의 예제를 `const enum Flavor`로 바꾸면, 컴파일러는 Flavor.CHOCOLATE를 `0`으로 바꿔버린다.
  이런 결과는 기대하지 않은 것이며, 문자열 열거형과 숫자 열거형과 전혀 다른 동작이다.
- `preserveConstEnums` 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지한다.
- 문자열 열거형은 런타임의 타입 안정성과 투명성을 제공한다. 그러나 타입스크립트의 다른 타입과 달리 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.

```ts
// 문자열 열거형
enum Flavor {
  VANILLA = "vanilla",
  CHOCOLATE = "chocolate",
  STRAWBERRY = "strawberry",
}

function scoop(flavor: Flavor) {}
```

Flavor는 런타임 시점에는 문자열이기 때문에 자바스크립트에서는 다음처럼 호출할 수 있다.

```js
scoop("vanilla");
```

그러나 타입스크립트에서는 열거형을 임포트하고 문자열 대신 사용해야 한다.

```ts
scoop("vanilla"); // error

scoop(Flavor.VANILLA); // 정상
```

이처럼 자바스크립트와 타입스크립트에서 동작이 다르기 때문에 문자열 열거형은 사용하지 않는 것이 좋고, 리터럴 타입의 유니온을 사용하는 것을 권장한다.

```ts
type Flavor = "vanilla" | "chocolate" | "strawberry";
```

## 매개변수 속성

```ts
// 일반적
class Person {
  name: stirng;
  constructor(name: string) {
    this.name = name;
  }
}

// 매개변수 속성 사용
class Person {
  constructor(public name: string) {}
}
```

매개변수 속성의 문제점

- 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법
- 매개변수가 속성이 런타임에는 실제로 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보임
- 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워짐

## 네임스페이스와 트리플 슬래시 임포트

ECMAScript 2015 이전에는 자바스크립트에 공식적인 모듈 시스템이 없었다.

타입스크립트 역시 자체적으로 모듈 시스템을 구축했고, module 키워드와 '트리플 슬래시' 임포트를 사용했다.

ECMAScript 2015가 공식적으로 모듈 시스템을 도입한 이후, 타입스크립트는 충돌을 피하기 위해 module과 같은 기능을 하는 namespace 키워드를 추가했다.

```ts
namespace foo {
  function bar() {}
}

/// <reference path="other.ts">
foo.bar();
```

이는 호환성을 위해 남아 있을 뿐이며, 이제는 ECMAScript 2015 스타일의 모듈을 사용해야 한다.

## 데코레이터

데코레이터 기능은 현재까지도 표준화가 완료되지 않아, 비표준화되거나 호환성이 꺠질 가능성이 있다.

앵귤러를 사용하거나 어노테이션이 필요한 프레임워크를 사용하고 있는 게 아니라면, 데코레이터가 표준이 되기 전에는 타입스크립트에서 데코레이터를 사용하지 않는 게 좋다.

## 요약

- 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만,
  열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않는다.

- 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 게 좋다.

